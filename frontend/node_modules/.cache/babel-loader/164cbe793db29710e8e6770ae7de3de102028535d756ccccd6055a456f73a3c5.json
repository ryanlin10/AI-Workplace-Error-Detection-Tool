{"ast":null,"code":"var _jsxFileName = \"/Users/suleimanmahmood/Documents/software engineering stuff/BuildX2/frontend/src/components/VideoCapture.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport './VideoCapture.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoCapture = ({\n  isActive,\n  onImageCapture\n}) => {\n  _s();\n  const videoRef = useRef(null);\n  const streamRef = useRef(null);\n  const canvasRef = useRef(document.createElement('canvas'));\n  const [isCameraReady, setIsCameraReady] = useState(false);\n  const [cameraError, setCameraError] = useState(false);\n  const [hasValidImage, setHasValidImage] = useState(false);\n  const [cameraStatus, setCameraStatus] = useState('Initializing camera...');\n\n  // Function to check if an image is blank/black\n  const isImageBlank = imageData => {\n    // Create a temporary canvas to analyze the image\n    const tempCanvas = document.createElement('canvas');\n    const tempCtx = tempCanvas.getContext('2d');\n    const img = new Image();\n\n    // Set up a promise to handle the async image loading\n    return new Promise(resolve => {\n      img.onload = () => {\n        tempCanvas.width = img.width;\n        tempCanvas.height = img.height;\n        tempCtx.drawImage(img, 0, 0);\n\n        // Get image data and check if it's mostly black\n        const data = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;\n        let nonBlackPixels = 0;\n        const totalPixels = data.length / 4;\n\n        // Sample pixels to check for non-black content\n        for (let i = 0; i < data.length; i += 16) {\n          const r = data[i];\n          const g = data[i + 1];\n          const b = data[i + 2];\n\n          // If pixel is not black (allowing some noise)\n          if (r > 10 || g > 10 || b > 10) {\n            nonBlackPixels++;\n          }\n        }\n\n        // If less than 5% of sampled pixels are non-black, consider it blank\n        const isBlank = nonBlackPixels / (totalPixels / 4) < 0.05;\n        console.log(`Image analysis: ${nonBlackPixels} non-black pixels out of ${totalPixels / 4} sampled. Blank: ${isBlank}`);\n        resolve(isBlank);\n      };\n      img.onerror = () => {\n        console.error('Error analyzing image');\n        resolve(true); // Assume blank on error\n      };\n      img.src = imageData;\n    });\n  };\n\n  // Function to capture image from video\n  const captureImage = useCallback(async () => {\n    if (!videoRef.current) {\n      console.warn('Video element not available');\n      return false;\n    }\n    if (!isCameraReady) {\n      console.warn('Camera not ready yet');\n      return false;\n    }\n    if (videoRef.current.videoWidth <= 0 || videoRef.current.videoHeight <= 0) {\n      console.warn('Video dimensions not available yet');\n      return false;\n    }\n    console.log('Capturing image from video', {\n      videoWidth: videoRef.current.videoWidth,\n      videoHeight: videoRef.current.videoHeight,\n      readyState: videoRef.current.readyState\n    });\n    try {\n      // Force a draw to make sure there's a frame to capture\n      if (videoRef.current.readyState < 2) {\n        console.warn('Video not fully loaded, waiting...');\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n\n      // Ensure canvas dimensions match video\n      canvasRef.current.width = videoRef.current.videoWidth || 640;\n      canvasRef.current.height = videoRef.current.videoHeight || 480;\n\n      // Draw the current video frame to canvas\n      const ctx = canvasRef.current.getContext('2d');\n      ctx.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n\n      // Convert to data URL with higher quality\n      const imageDataUrl = canvasRef.current.toDataURL('image/jpeg', 0.95);\n      console.log('Raw image captured, data URL length:', imageDataUrl.length);\n\n      // Check if the image is blank\n      const isBlank = await isImageBlank(imageDataUrl);\n      if (isBlank) {\n        console.warn('Captured image appears to be blank');\n        return false;\n      }\n      console.log('Valid image captured successfully, data URL length:', imageDataUrl.length);\n\n      // Add a small delay to ensure the state updates properly\n      setTimeout(() => {\n        onImageCapture(imageDataUrl);\n        setHasValidImage(true);\n      }, 100);\n      return true;\n    } catch (error) {\n      console.error('Error capturing image:', error);\n      return false;\n    }\n  }, [onImageCapture, isCameraReady]);\n\n  // Create a dedicated capture function that users can call\n  const forceCapture = async () => {\n    setCameraStatus('Capturing image...');\n    const success = await captureImage();\n    setCameraStatus(success ? 'Image captured!' : 'Failed to capture image');\n\n    // Reset status after a delay\n    setTimeout(() => {\n      setCameraStatus(isCameraReady ? 'Camera ready' : 'Initializing camera...');\n    }, 2000);\n  };\n\n  // Periodic image capture during recording\n  useEffect(() => {\n    let captureInterval;\n    if (isActive && isCameraReady) {\n      // Wait a bit longer before first capture to ensure video is rendering\n      const initialCaptureDelay = 3000;\n      console.log(`Scheduling initial capture in ${initialCaptureDelay}ms`);\n      const initialCaptureTimeout = setTimeout(async () => {\n        const success = await captureImage();\n        if (!success) {\n          console.log('Initial capture failed, trying again in 2 seconds');\n          setTimeout(captureImage, 2000);\n        }\n      }, initialCaptureDelay);\n\n      // Set up interval to capture image every 5 seconds during recording if no valid image yet\n      captureInterval = setInterval(async () => {\n        if (!hasValidImage) {\n          console.log('Attempting periodic capture');\n          await captureImage();\n        }\n      }, 5000);\n      return () => {\n        clearTimeout(initialCaptureTimeout);\n        if (captureInterval) {\n          clearInterval(captureInterval);\n        }\n      };\n    }\n    return () => {\n      if (captureInterval) {\n        clearInterval(captureInterval);\n      }\n    };\n  }, [isActive, isCameraReady, captureImage, hasValidImage]);\n\n  // Handle camera setup and teardown\n  useEffect(() => {\n    if (isActive && !isCameraReady && !cameraError) {\n      console.log('Starting camera');\n      setHasValidImage(false);\n      setCameraStatus('Initializing camera...');\n\n      // Start camera with specific constraints for better quality\n      navigator.mediaDevices.getUserMedia({\n        video: {\n          width: {\n            ideal: 1280\n          },\n          height: {\n            ideal: 720\n          },\n          facingMode: 'user'\n        }\n      }).then(stream => {\n        console.log('Camera access granted');\n        streamRef.current = stream;\n        if (videoRef.current) {\n          // Set srcObject to the stream\n          videoRef.current.srcObject = stream;\n\n          // Listen for loadedmetadata event\n          videoRef.current.onloadedmetadata = () => {\n            console.log('Video metadata loaded');\n\n            // Play the video\n            videoRef.current.play().then(() => {\n              console.log('Video playback started');\n              setCameraStatus('Camera ready');\n\n              // Wait a moment to ensure video is actually rendering frames\n              setTimeout(() => {\n                setIsCameraReady(true);\n              }, 1500);\n            }).catch(error => {\n              console.error('Error starting video playback:', error);\n              setCameraError(true);\n              setCameraStatus('Camera error: ' + error.message);\n            });\n          };\n\n          // Listen for errors\n          videoRef.current.onerror = error => {\n            console.error('Video element error:', error);\n            setCameraError(true);\n            setCameraStatus('Video error: ' + (error.message || 'Unknown error'));\n          };\n        }\n      }).catch(error => {\n        console.error('Error accessing camera:', error);\n        setCameraError(true);\n        setCameraStatus('Camera access error: ' + error.message);\n      });\n    } else if (!isActive) {\n      // Stop camera and capture final image if we were active\n      if (streamRef.current && isCameraReady) {\n        console.log('Stopping camera and capturing final image');\n        setCameraStatus('Capturing final image...');\n\n        // Try to capture one last image before stopping\n        const captureFinalImage = async () => {\n          // Try up to 3 times to get a non-blank image\n          let captured = false;\n          for (let i = 0; i < 3 && !captured; i++) {\n            console.log(`Final capture attempt ${i + 1}/3`);\n            const success = await captureImage();\n            if (success) {\n              console.log('Final capture successful');\n              captured = true;\n            } else if (i < 2) {\n              // Short delay between attempts\n              await new Promise(resolve => setTimeout(resolve, 500));\n            }\n          }\n\n          // Stop all tracks\n          streamRef.current.getTracks().forEach(track => {\n            track.stop();\n            console.log(`Track ${track.kind} stopped`);\n          });\n          streamRef.current = null;\n          setIsCameraReady(false);\n          setCameraStatus('Camera stopped');\n        };\n        captureFinalImage();\n      }\n    }\n    return () => {\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [isActive, isCameraReady, captureImage, cameraError]);\n\n  // Manual capture button handler\n  const handleManualCapture = async () => {\n    if (isCameraReady) {\n      console.log('Manual capture triggered');\n      await forceCapture();\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"video-capture\",\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      className: isActive ? 'active' : 'inactive',\n      muted: true,\n      playsInline: true,\n      autoPlay: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 288,\n      columnNumber: 7\n    }, this), isActive && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"camera-controls\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"status-indicator\",\n        children: [cameraStatus, hasValidImage && /*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"checkmark\",\n          children: \"\\u2713\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 300,\n          columnNumber: 31\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 298,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"capture-button\",\n        onClick: handleManualCapture,\n        disabled: !isCameraReady,\n        title: \"Take a snapshot\",\n        children: \"\\uD83D\\uDCF7 Capture Image Now\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 303,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 297,\n      columnNumber: 9\n    }, this), !isActive && !isCameraReady && !cameraError && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"camera-inactive\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Click \\\"Start Stream\\\" to activate camera\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 316,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 315,\n      columnNumber: 9\n    }, this), cameraError && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"camera-error\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: cameraStatus || 'Camera access error. Please check your permissions.'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 322,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 321,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 287,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoCapture, \"TWyeKNb4SB9DE7Kp+CAJymN3ePk=\");\n_c = VideoCapture;\nexport default VideoCapture;\nvar _c;\n$RefreshReg$(_c, \"VideoCapture\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","jsxDEV","_jsxDEV","VideoCapture","isActive","onImageCapture","_s","videoRef","streamRef","canvasRef","document","createElement","isCameraReady","setIsCameraReady","cameraError","setCameraError","hasValidImage","setHasValidImage","cameraStatus","setCameraStatus","isImageBlank","imageData","tempCanvas","tempCtx","getContext","img","Image","Promise","resolve","onload","width","height","drawImage","data","getImageData","nonBlackPixels","totalPixels","length","i","r","g","b","isBlank","console","log","onerror","error","src","captureImage","current","warn","videoWidth","videoHeight","readyState","setTimeout","ctx","imageDataUrl","toDataURL","forceCapture","success","captureInterval","initialCaptureDelay","initialCaptureTimeout","setInterval","clearTimeout","clearInterval","navigator","mediaDevices","getUserMedia","video","ideal","facingMode","then","stream","srcObject","onloadedmetadata","play","catch","message","captureFinalImage","captured","getTracks","forEach","track","stop","kind","handleManualCapture","className","children","ref","muted","playsInline","autoPlay","fileName","_jsxFileName","lineNumber","columnNumber","onClick","disabled","title","_c","$RefreshReg$"],"sources":["/Users/suleimanmahmood/Documents/software engineering stuff/BuildX2/frontend/src/components/VideoCapture.js"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\nimport './VideoCapture.css';\n\nconst VideoCapture = ({ isActive, onImageCapture }) => {\n  const videoRef = useRef(null);\n  const streamRef = useRef(null);\n  const canvasRef = useRef(document.createElement('canvas'));\n  const [isCameraReady, setIsCameraReady] = useState(false);\n  const [cameraError, setCameraError] = useState(false);\n  const [hasValidImage, setHasValidImage] = useState(false);\n  const [cameraStatus, setCameraStatus] = useState('Initializing camera...');\n  \n  // Function to check if an image is blank/black\n  const isImageBlank = (imageData) => {\n    // Create a temporary canvas to analyze the image\n    const tempCanvas = document.createElement('canvas');\n    const tempCtx = tempCanvas.getContext('2d');\n    const img = new Image();\n    \n    // Set up a promise to handle the async image loading\n    return new Promise((resolve) => {\n      img.onload = () => {\n        tempCanvas.width = img.width;\n        tempCanvas.height = img.height;\n        tempCtx.drawImage(img, 0, 0);\n        \n        // Get image data and check if it's mostly black\n        const data = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;\n        let nonBlackPixels = 0;\n        const totalPixels = data.length / 4;\n        \n        // Sample pixels to check for non-black content\n        for (let i = 0; i < data.length; i += 16) {\n          const r = data[i];\n          const g = data[i + 1];\n          const b = data[i + 2];\n          \n          // If pixel is not black (allowing some noise)\n          if (r > 10 || g > 10 || b > 10) {\n            nonBlackPixels++;\n          }\n        }\n        \n        // If less than 5% of sampled pixels are non-black, consider it blank\n        const isBlank = (nonBlackPixels / (totalPixels / 4)) < 0.05;\n        console.log(`Image analysis: ${nonBlackPixels} non-black pixels out of ${totalPixels / 4} sampled. Blank: ${isBlank}`);\n        resolve(isBlank);\n      };\n      \n      img.onerror = () => {\n        console.error('Error analyzing image');\n        resolve(true); // Assume blank on error\n      };\n      \n      img.src = imageData;\n    });\n  };\n  \n  // Function to capture image from video\n  const captureImage = useCallback(async () => {\n    if (!videoRef.current) {\n      console.warn('Video element not available');\n      return false;\n    }\n    \n    if (!isCameraReady) {\n      console.warn('Camera not ready yet');\n      return false;\n    }\n    \n    if (videoRef.current.videoWidth <= 0 || videoRef.current.videoHeight <= 0) {\n      console.warn('Video dimensions not available yet');\n      return false;\n    }\n    \n    console.log('Capturing image from video', {\n      videoWidth: videoRef.current.videoWidth,\n      videoHeight: videoRef.current.videoHeight,\n      readyState: videoRef.current.readyState\n    });\n    \n    try {\n      // Force a draw to make sure there's a frame to capture\n      if (videoRef.current.readyState < 2) {\n        console.warn('Video not fully loaded, waiting...');\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n      \n      // Ensure canvas dimensions match video\n      canvasRef.current.width = videoRef.current.videoWidth || 640;\n      canvasRef.current.height = videoRef.current.videoHeight || 480;\n      \n      // Draw the current video frame to canvas\n      const ctx = canvasRef.current.getContext('2d');\n      ctx.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n      \n      // Convert to data URL with higher quality\n      const imageDataUrl = canvasRef.current.toDataURL('image/jpeg', 0.95);\n      \n      console.log('Raw image captured, data URL length:', imageDataUrl.length);\n      \n      // Check if the image is blank\n      const isBlank = await isImageBlank(imageDataUrl);\n      \n      if (isBlank) {\n        console.warn('Captured image appears to be blank');\n        return false;\n      }\n      \n      console.log('Valid image captured successfully, data URL length:', imageDataUrl.length);\n      \n      // Add a small delay to ensure the state updates properly\n      setTimeout(() => {\n        onImageCapture(imageDataUrl);\n        setHasValidImage(true);\n      }, 100);\n      \n      return true;\n    } catch (error) {\n      console.error('Error capturing image:', error);\n      return false;\n    }\n  }, [onImageCapture, isCameraReady]);\n  \n  // Create a dedicated capture function that users can call\n  const forceCapture = async () => {\n    setCameraStatus('Capturing image...');\n    const success = await captureImage();\n    setCameraStatus(success ? 'Image captured!' : 'Failed to capture image');\n    \n    // Reset status after a delay\n    setTimeout(() => {\n      setCameraStatus(isCameraReady ? 'Camera ready' : 'Initializing camera...');\n    }, 2000);\n  };\n  \n  // Periodic image capture during recording\n  useEffect(() => {\n    let captureInterval;\n    \n    if (isActive && isCameraReady) {\n      // Wait a bit longer before first capture to ensure video is rendering\n      const initialCaptureDelay = 3000;\n      console.log(`Scheduling initial capture in ${initialCaptureDelay}ms`);\n      \n      const initialCaptureTimeout = setTimeout(async () => {\n        const success = await captureImage();\n        if (!success) {\n          console.log('Initial capture failed, trying again in 2 seconds');\n          setTimeout(captureImage, 2000);\n        }\n      }, initialCaptureDelay);\n      \n      // Set up interval to capture image every 5 seconds during recording if no valid image yet\n      captureInterval = setInterval(async () => {\n        if (!hasValidImage) {\n          console.log('Attempting periodic capture');\n          await captureImage();\n        }\n      }, 5000);\n      \n      return () => {\n        clearTimeout(initialCaptureTimeout);\n        if (captureInterval) {\n          clearInterval(captureInterval);\n        }\n      };\n    }\n    \n    return () => {\n      if (captureInterval) {\n        clearInterval(captureInterval);\n      }\n    };\n  }, [isActive, isCameraReady, captureImage, hasValidImage]);\n  \n  // Handle camera setup and teardown\n  useEffect(() => {\n    if (isActive && !isCameraReady && !cameraError) {\n      console.log('Starting camera');\n      setHasValidImage(false);\n      setCameraStatus('Initializing camera...');\n      \n      // Start camera with specific constraints for better quality\n      navigator.mediaDevices.getUserMedia({ \n        video: { \n          width: { ideal: 1280 },\n          height: { ideal: 720 },\n          facingMode: 'user'\n        } \n      })\n        .then(stream => {\n          console.log('Camera access granted');\n          streamRef.current = stream;\n          \n          if (videoRef.current) {\n            // Set srcObject to the stream\n            videoRef.current.srcObject = stream;\n            \n            // Listen for loadedmetadata event\n            videoRef.current.onloadedmetadata = () => {\n              console.log('Video metadata loaded');\n              \n              // Play the video\n              videoRef.current.play()\n                .then(() => {\n                  console.log('Video playback started');\n                  setCameraStatus('Camera ready');\n                  \n                  // Wait a moment to ensure video is actually rendering frames\n                  setTimeout(() => {\n                    setIsCameraReady(true);\n                  }, 1500);\n                })\n                .catch(error => {\n                  console.error('Error starting video playback:', error);\n                  setCameraError(true);\n                  setCameraStatus('Camera error: ' + error.message);\n                });\n            };\n            \n            // Listen for errors\n            videoRef.current.onerror = (error) => {\n              console.error('Video element error:', error);\n              setCameraError(true);\n              setCameraStatus('Video error: ' + (error.message || 'Unknown error'));\n            };\n          }\n        })\n        .catch(error => {\n          console.error('Error accessing camera:', error);\n          setCameraError(true);\n          setCameraStatus('Camera access error: ' + error.message);\n        });\n    } else if (!isActive) {\n      // Stop camera and capture final image if we were active\n      if (streamRef.current && isCameraReady) {\n        console.log('Stopping camera and capturing final image');\n        setCameraStatus('Capturing final image...');\n        \n        // Try to capture one last image before stopping\n        const captureFinalImage = async () => {\n          // Try up to 3 times to get a non-blank image\n          let captured = false;\n          for (let i = 0; i < 3 && !captured; i++) {\n            console.log(`Final capture attempt ${i + 1}/3`);\n            const success = await captureImage();\n            if (success) {\n              console.log('Final capture successful');\n              captured = true;\n            } else if (i < 2) {\n              // Short delay between attempts\n              await new Promise(resolve => setTimeout(resolve, 500));\n            }\n          }\n          \n          // Stop all tracks\n          streamRef.current.getTracks().forEach(track => {\n            track.stop();\n            console.log(`Track ${track.kind} stopped`);\n          });\n          streamRef.current = null;\n          setIsCameraReady(false);\n          setCameraStatus('Camera stopped');\n        };\n        \n        captureFinalImage();\n      }\n    }\n    \n    return () => {\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [isActive, isCameraReady, captureImage, cameraError]);\n  \n  // Manual capture button handler\n  const handleManualCapture = async () => {\n    if (isCameraReady) {\n      console.log('Manual capture triggered');\n      await forceCapture();\n    }\n  };\n  \n  return (\n    <div className=\"video-capture\">\n      <video \n        ref={videoRef} \n        className={isActive ? 'active' : 'inactive'} \n        muted\n        playsInline\n        autoPlay\n      />\n      \n      {isActive && (\n        <div className=\"camera-controls\">\n          <div className=\"status-indicator\">\n            {cameraStatus}\n            {hasValidImage && <span className=\"checkmark\">âœ“</span>}\n          </div>\n          \n          <button \n            className=\"capture-button\"\n            onClick={handleManualCapture}\n            disabled={!isCameraReady}\n            title=\"Take a snapshot\"\n          >\n            ðŸ“· Capture Image Now\n          </button>\n        </div>\n      )}\n      \n      {!isActive && !isCameraReady && !cameraError && (\n        <div className=\"camera-inactive\">\n          <p>Click \"Start Stream\" to activate camera</p>\n        </div>\n      )}\n      \n      {cameraError && (\n        <div className=\"camera-error\">\n          <p>{cameraStatus || 'Camera access error. Please check your permissions.'}</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default VideoCapture; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
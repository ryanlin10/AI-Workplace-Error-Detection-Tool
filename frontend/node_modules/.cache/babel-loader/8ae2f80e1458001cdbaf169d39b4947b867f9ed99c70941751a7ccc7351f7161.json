{"ast":null,"code":"var _jsxFileName = \"/Users/suleimanmahmood/Documents/software engineering stuff/BuildX2/frontend/src/components/VideoCapture.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport axios from 'axios';\nimport './VideoCapture.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoCapture = ({\n  isActive,\n  onImageCapture\n}) => {\n  _s();\n  const videoRef = useRef(null);\n  const streamRef = useRef(null);\n  const canvasRef = useRef(document.createElement('canvas'));\n  const [isCameraReady, setIsCameraReady] = useState(false);\n  const [cameraError, setCameraError] = useState(false);\n  const [hasValidImage, setHasValidImage] = useState(false);\n  const [cameraStatus, setCameraStatus] = useState('Initializing camera...');\n  const [storedImage, setStoredImage] = useState(null);\n  const [captureMode, setCaptureMode] = useState('face'); // 'face' or 'medical'\n  const [faceRecognitionResult, setFaceRecognitionResult] = useState(null);\n  const [faceRecognitionLoading, setFaceRecognitionLoading] = useState(false);\n  const [imageAnalysisResult, setImageAnalysisResult] = useState(null);\n  const [imageAnalysisLoading, setImageAnalysisLoading] = useState(false);\n\n  // Function to check if an image is blank/black\n  const isImageBlank = imageData => {\n    // Create a temporary canvas to analyze the image\n    const tempCanvas = document.createElement('canvas');\n    const tempCtx = tempCanvas.getContext('2d');\n    const img = new Image();\n\n    // Set up a promise to handle the async image loading\n    return new Promise(resolve => {\n      img.onload = () => {\n        tempCanvas.width = img.width;\n        tempCanvas.height = img.height;\n        tempCtx.drawImage(img, 0, 0);\n\n        // Get image data and check if it's mostly black\n        const data = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;\n        let nonBlackPixels = 0;\n        const totalPixels = data.length / 4;\n\n        // Sample pixels to check for non-black content\n        for (let i = 0; i < data.length; i += 16) {\n          const r = data[i];\n          const g = data[i + 1];\n          const b = data[i + 2];\n\n          // If pixel is not black (allowing some noise)\n          if (r > 10 || g > 10 || b > 10) {\n            nonBlackPixels++;\n          }\n        }\n\n        // If less than 5% of sampled pixels are non-black, consider it blank\n        const isBlank = nonBlackPixels / (totalPixels / 4) < 0.05;\n        console.log(`Image analysis: ${nonBlackPixels} non-black pixels out of ${totalPixels / 4} sampled. Blank: ${isBlank}`);\n        resolve(isBlank);\n      };\n      img.onerror = () => {\n        console.error('Error analyzing image');\n        resolve(true); // Assume blank on error\n      };\n      img.src = imageData;\n    });\n  };\n\n  // Function to capture image from video\n  const captureImage = useCallback(async () => {\n    if (!videoRef.current) {\n      console.warn('Video element not available');\n      return false;\n    }\n    if (!isCameraReady) {\n      console.warn('Camera not ready yet');\n      return false;\n    }\n    if (videoRef.current.videoWidth <= 0 || videoRef.current.videoHeight <= 0) {\n      console.warn('Video dimensions not available yet');\n      return false;\n    }\n    console.log('Capturing image from video', {\n      videoWidth: videoRef.current.videoWidth,\n      videoHeight: videoRef.current.videoHeight,\n      readyState: videoRef.current.readyState\n    });\n    try {\n      // Force a draw to make sure there's a frame to capture\n      if (videoRef.current.readyState < 2) {\n        console.warn('Video not fully loaded, waiting...');\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n\n      // Ensure canvas dimensions match video\n      canvasRef.current.width = videoRef.current.videoWidth || 640;\n      canvasRef.current.height = videoRef.current.videoHeight || 480;\n\n      // Draw the current video frame to canvas\n      const ctx = canvasRef.current.getContext('2d');\n      ctx.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n\n      // Convert to data URL with higher quality\n      const imageDataUrl = canvasRef.current.toDataURL('image/jpeg', 0.95);\n      console.log('Raw image captured, data URL length:', imageDataUrl.length);\n\n      // Check if the image is blank\n      const isBlank = await isImageBlank(imageDataUrl);\n      if (isBlank) {\n        console.warn('Captured image appears to be blank');\n        return false;\n      }\n      console.log('Valid image captured successfully, data URL length:', imageDataUrl.length);\n\n      // Store the image and notify parent component\n      setStoredImage(imageDataUrl);\n      setHasValidImage(true);\n      onImageCapture(imageDataUrl);\n\n      // Process the image based on the current mode\n      if (captureMode === 'face') {\n        await processFaceRecognition(imageDataUrl);\n      } else if (captureMode === 'medical') {\n        await processMedicalImageAnalysis(imageDataUrl);\n      }\n      return true;\n    } catch (error) {\n      console.error('Error capturing image:', error);\n      return false;\n    }\n  }, [onImageCapture, isCameraReady, captureMode]);\n\n  // Function to process face recognition\n  const processFaceRecognition = async imageData => {\n    try {\n      setFaceRecognitionLoading(true);\n      setFaceRecognitionResult(null);\n      console.log('Sending image for face recognition...');\n      const response = await axios.post('http://localhost:8080/api/recognize-face', {\n        image: imageData\n      });\n      console.log('Face recognition result:', response.data);\n      setFaceRecognitionResult(response.data);\n\n      // Switch to medical image mode after face recognition is done\n      setCaptureMode('medical');\n    } catch (error) {\n      var _error$response, _error$response$data;\n      console.error('Error in face recognition:', error);\n      setFaceRecognitionResult({\n        success: false,\n        error: ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : (_error$response$data = _error$response.data) === null || _error$response$data === void 0 ? void 0 : _error$response$data.error) || 'Error processing face recognition'\n      });\n    } finally {\n      setFaceRecognitionLoading(false);\n    }\n  };\n\n  // Function to process medical image analysis\n  const processMedicalImageAnalysis = async imageData => {\n    try {\n      setImageAnalysisLoading(true);\n      setImageAnalysisResult(null);\n      console.log('Sending image for medical analysis...');\n      const response = await axios.post('http://localhost:8080/api/analyze-image', {\n        image: imageData\n      });\n      console.log('Medical image analysis result:', response.data);\n      setImageAnalysisResult(response.data);\n    } catch (error) {\n      var _error$response2, _error$response2$data;\n      console.error('Error in medical image analysis:', error);\n      setImageAnalysisResult({\n        success: false,\n        error: ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.error) || 'Error processing image analysis'\n      });\n    } finally {\n      setImageAnalysisLoading(false);\n    }\n  };\n\n  // Manual capture button handler with status updates\n  const handleManualCapture = async () => {\n    if (isCameraReady) {\n      console.log('Manual capture triggered');\n      setCameraStatus(`Capturing ${captureMode === 'face' ? 'face' : 'medical'} image...`);\n      const success = await captureImage();\n      if (success) {\n        setCameraStatus(`${captureMode === 'face' ? 'Face' : 'Medical'} image captured successfully!`);\n      } else {\n        setCameraStatus('Failed to capture image. Try again.');\n      }\n\n      // Reset status after a delay\n      setTimeout(() => {\n        setCameraStatus(isCameraReady ? 'Camera active' : 'Initializing camera...');\n      }, 2000);\n    }\n  };\n\n  // Function to retry capture if needed\n  const handleRetryCapture = async () => {\n    setHasValidImage(false);\n    await handleManualCapture();\n  };\n\n  // Reset capture mode when starting a new stream\n  useEffect(() => {\n    if (isActive) {\n      setCaptureMode('face');\n      setFaceRecognitionResult(null);\n      setImageAnalysisResult(null);\n    }\n  }, [isActive]);\n\n  // When stream ends, ensure the parent has the latest image\n  useEffect(() => {\n    if (!isActive && storedImage) {\n      console.log('Stream ended, ensuring parent has the latest captured image');\n      onImageCapture(storedImage);\n    }\n  }, [isActive, storedImage, onImageCapture]);\n\n  // Handle camera setup and teardown\n  useEffect(() => {\n    if (isActive && !cameraError) {\n      console.log('Starting camera');\n      setCameraStatus('Initializing camera...');\n\n      // Reset hasValidImage but keep any stored image\n      if (!storedImage) {\n        setHasValidImage(false);\n      }\n\n      // Only initialize the camera if it's not already ready\n      if (!isCameraReady || !streamRef.current) {\n        // Start camera with specific constraints for better quality\n        navigator.mediaDevices.getUserMedia({\n          video: {\n            width: {\n              ideal: 1280\n            },\n            height: {\n              ideal: 720\n            },\n            facingMode: 'user'\n          }\n        }).then(stream => {\n          console.log('Camera access granted');\n          streamRef.current = stream;\n          if (videoRef.current) {\n            // Set srcObject to the stream\n            videoRef.current.srcObject = stream;\n\n            // Listen for loadedmetadata event\n            videoRef.current.onloadedmetadata = () => {\n              console.log('Video metadata loaded');\n\n              // Play the video\n              videoRef.current.play().then(() => {\n                console.log('Video playback started');\n                setCameraStatus(`Camera active - Click \"Capture ${captureMode === 'face' ? 'Face' : 'Medical Image'}\" button when ready`);\n\n                // Wait a moment to ensure video is actually rendering frames\n                setTimeout(() => {\n                  setIsCameraReady(true);\n                }, 1000);\n              }).catch(error => {\n                console.error('Error starting video playback:', error);\n                setCameraError(true);\n                setCameraStatus('Camera error: ' + error.message);\n              });\n            };\n\n            // Listen for errors\n            videoRef.current.onerror = error => {\n              console.error('Video element error:', error);\n              setCameraError(true);\n              setCameraStatus('Video error: ' + (error.message || 'Unknown error'));\n            };\n          }\n        }).catch(error => {\n          console.error('Error accessing camera:', error);\n          setCameraError(true);\n          setCameraStatus('Camera access error: ' + error.message);\n        });\n      } else {\n        // Camera is already initialized, just update the status\n        setCameraStatus(`Camera active - Click \"Capture ${captureMode === 'face' ? 'Face' : 'Medical Image'}\" button when ready`);\n      }\n    } else if (!isActive) {\n      // Stop camera when stream ends\n      if (streamRef.current) {\n        console.log('Stopping camera');\n        setCameraStatus('Stopping camera...');\n\n        // Stop all tracks\n        streamRef.current.getTracks().forEach(track => {\n          track.stop();\n          console.log(`Track ${track.kind} stopped`);\n        });\n        streamRef.current = null;\n        setIsCameraReady(false);\n        setCameraStatus('Camera stopped');\n      }\n    }\n    return () => {\n      // Only stop the camera in the cleanup function if isActive is false\n      // This prevents stopping the camera when the component re-renders\n      if (!isActive && streamRef.current) {\n        console.log('Cleanup: stopping camera tracks');\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [isActive, cameraError, storedImage, captureMode]); // Added captureMode to dependencies\n\n  // Render face recognition result\n  const renderFaceRecognition = () => {\n    if (faceRecognitionLoading) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"analysis-loading\",\n        children: \"Identifying person...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 333,\n        columnNumber: 14\n      }, this);\n    }\n    if (faceRecognitionResult && faceRecognitionResult.success) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"face-recognition-result\",\n        children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n          children: \"Person Identified:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 339,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"person-info\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"person-id\",\n            children: [\"ID: \", faceRecognitionResult.person_id]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 341,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"person-name\",\n            children: faceRecognitionResult.person_name\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 342,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"person-profession\",\n            children: faceRecognitionResult.person_profession\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 343,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"confidence\",\n            children: [\"Confidence: \", faceRecognitionResult.confidence, \"%\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 344,\n            columnNumber: 13\n          }, this), faceRecognitionResult.reference_comparison && faceRecognitionResult.reference_image_url && /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"reference-image-container\",\n            children: [/*#__PURE__*/_jsxDEV(\"p\", {\n              children: \"Matched with reference image:\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 347,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"img\", {\n              src: `http://localhost:8080${faceRecognitionResult.reference_image_url}`,\n              alt: `Reference for ${faceRecognitionResult.person_name}`,\n              className: \"reference-image\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 348,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 346,\n            columnNumber: 15\n          }, this), faceRecognitionResult.is_fallback && /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"fallback-notice\",\n            children: \"Note: Using simulated recognition (API issue)\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 356,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 340,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 338,\n        columnNumber: 9\n      }, this);\n    }\n    if (faceRecognitionResult && !faceRecognitionResult.success) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"face-recognition-error\",\n        children: /*#__PURE__*/_jsxDEV(\"p\", {\n          children: [\"Error identifying person: \", faceRecognitionResult.error]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 368,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 367,\n        columnNumber: 9\n      }, this);\n    }\n    return null;\n  };\n\n  // Render medical image analysis result\n  const renderImageAnalysis = () => {\n    if (imageAnalysisLoading) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"analysis-loading\",\n        children: \"Analyzing image...\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 379,\n        columnNumber: 14\n      }, this);\n    }\n    if (imageAnalysisResult && imageAnalysisResult.success) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"image-analysis-result\",\n        children: [/*#__PURE__*/_jsxDEV(\"h4\", {\n          children: \"Image Analysis:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 385,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"analysis-text\",\n          children: imageAnalysisResult.analysis\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 386,\n          columnNumber: 11\n        }, this), imageAnalysisResult.is_fallback && /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"fallback-notice\",\n          children: \"Note: Using simulated analysis (API issue)\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 388,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 384,\n        columnNumber: 9\n      }, this);\n    }\n    if (imageAnalysisResult && !imageAnalysisResult.success) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"image-analysis-error\",\n        children: /*#__PURE__*/_jsxDEV(\"p\", {\n          children: [\"Error analyzing image: \", imageAnalysisResult.error]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 399,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 398,\n        columnNumber: 9\n      }, this);\n    }\n    return null;\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"video-capture-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"video-capture\",\n      children: [/*#__PURE__*/_jsxDEV(\"video\", {\n        ref: videoRef,\n        className: isActive ? 'active' : 'inactive',\n        muted: true,\n        playsInline: true,\n        autoPlay: true\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 410,\n        columnNumber: 9\n      }, this), isActive && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"camera-controls\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"status-indicator\",\n          children: [cameraStatus, hasValidImage && /*#__PURE__*/_jsxDEV(\"span\", {\n            className: \"checkmark\",\n            children: \"\\u2713\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 422,\n            columnNumber: 33\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 420,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"buttons\",\n          children: [/*#__PURE__*/_jsxDEV(\"button\", {\n            className: \"capture-button\",\n            onClick: handleManualCapture,\n            disabled: !isCameraReady,\n            title: `Take a ${captureMode === 'face' ? 'face' : 'medical'} image`,\n            children: [\"\\uD83D\\uDCF7 Capture \", captureMode === 'face' ? 'Face' : 'Medical Image']\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 426,\n            columnNumber: 15\n          }, this), hasValidImage && /*#__PURE__*/_jsxDEV(\"button\", {\n            className: \"retry-button\",\n            onClick: handleRetryCapture,\n            disabled: !isCameraReady,\n            title: `Capture a new ${captureMode === 'face' ? 'face' : 'medical'} image`,\n            children: \"\\uD83D\\uDD04 Retry\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 436,\n            columnNumber: 17\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 425,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 419,\n        columnNumber: 11\n      }, this), !isActive && hasValidImage && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"image-saved-indicator\",\n        children: /*#__PURE__*/_jsxDEV(\"p\", {\n          children: \"Image saved and will be sent with your audio\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 451,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 450,\n        columnNumber: 11\n      }, this), !isActive && !hasValidImage && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"camera-inactive\",\n        children: /*#__PURE__*/_jsxDEV(\"p\", {\n          children: \"No image captured. Start stream to use camera.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 457,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 456,\n        columnNumber: 11\n      }, this), cameraError && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"camera-error\",\n        children: /*#__PURE__*/_jsxDEV(\"p\", {\n          children: cameraStatus || 'Camera access error. Please check your permissions.'\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 463,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 462,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 409,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"image-analysis-container\",\n      children: [renderFaceRecognition(), renderImageAnalysis()]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 468,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 408,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoCapture, \"7x386HsQHwf0uc3uKW6ZKrX0ojw=\");\n_c = VideoCapture;\nexport default VideoCapture;\nvar _c;\n$RefreshReg$(_c, \"VideoCapture\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","axios","jsxDEV","_jsxDEV","VideoCapture","isActive","onImageCapture","_s","videoRef","streamRef","canvasRef","document","createElement","isCameraReady","setIsCameraReady","cameraError","setCameraError","hasValidImage","setHasValidImage","cameraStatus","setCameraStatus","storedImage","setStoredImage","captureMode","setCaptureMode","faceRecognitionResult","setFaceRecognitionResult","faceRecognitionLoading","setFaceRecognitionLoading","imageAnalysisResult","setImageAnalysisResult","imageAnalysisLoading","setImageAnalysisLoading","isImageBlank","imageData","tempCanvas","tempCtx","getContext","img","Image","Promise","resolve","onload","width","height","drawImage","data","getImageData","nonBlackPixels","totalPixels","length","i","r","g","b","isBlank","console","log","onerror","error","src","captureImage","current","warn","videoWidth","videoHeight","readyState","setTimeout","ctx","imageDataUrl","toDataURL","processFaceRecognition","processMedicalImageAnalysis","response","post","image","_error$response","_error$response$data","success","_error$response2","_error$response2$data","handleManualCapture","handleRetryCapture","navigator","mediaDevices","getUserMedia","video","ideal","facingMode","then","stream","srcObject","onloadedmetadata","play","catch","message","getTracks","forEach","track","stop","kind","renderFaceRecognition","className","children","fileName","_jsxFileName","lineNumber","columnNumber","person_id","person_name","person_profession","confidence","reference_comparison","reference_image_url","alt","is_fallback","renderImageAnalysis","analysis","ref","muted","playsInline","autoPlay","onClick","disabled","title","_c","$RefreshReg$"],"sources":["/Users/suleimanmahmood/Documents/software engineering stuff/BuildX2/frontend/src/components/VideoCapture.js"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\nimport axios from 'axios';\nimport './VideoCapture.css';\n\nconst VideoCapture = ({ isActive, onImageCapture }) => {\n  const videoRef = useRef(null);\n  const streamRef = useRef(null);\n  const canvasRef = useRef(document.createElement('canvas'));\n  const [isCameraReady, setIsCameraReady] = useState(false);\n  const [cameraError, setCameraError] = useState(false);\n  const [hasValidImage, setHasValidImage] = useState(false);\n  const [cameraStatus, setCameraStatus] = useState('Initializing camera...');\n  const [storedImage, setStoredImage] = useState(null);\n  const [captureMode, setCaptureMode] = useState('face'); // 'face' or 'medical'\n  const [faceRecognitionResult, setFaceRecognitionResult] = useState(null);\n  const [faceRecognitionLoading, setFaceRecognitionLoading] = useState(false);\n  const [imageAnalysisResult, setImageAnalysisResult] = useState(null);\n  const [imageAnalysisLoading, setImageAnalysisLoading] = useState(false);\n  \n  // Function to check if an image is blank/black\n  const isImageBlank = (imageData) => {\n    // Create a temporary canvas to analyze the image\n    const tempCanvas = document.createElement('canvas');\n    const tempCtx = tempCanvas.getContext('2d');\n    const img = new Image();\n    \n    // Set up a promise to handle the async image loading\n    return new Promise((resolve) => {\n      img.onload = () => {\n        tempCanvas.width = img.width;\n        tempCanvas.height = img.height;\n        tempCtx.drawImage(img, 0, 0);\n        \n        // Get image data and check if it's mostly black\n        const data = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;\n        let nonBlackPixels = 0;\n        const totalPixels = data.length / 4;\n        \n        // Sample pixels to check for non-black content\n        for (let i = 0; i < data.length; i += 16) {\n          const r = data[i];\n          const g = data[i + 1];\n          const b = data[i + 2];\n          \n          // If pixel is not black (allowing some noise)\n          if (r > 10 || g > 10 || b > 10) {\n            nonBlackPixels++;\n          }\n        }\n        \n        // If less than 5% of sampled pixels are non-black, consider it blank\n        const isBlank = (nonBlackPixels / (totalPixels / 4)) < 0.05;\n        console.log(`Image analysis: ${nonBlackPixels} non-black pixels out of ${totalPixels / 4} sampled. Blank: ${isBlank}`);\n        resolve(isBlank);\n      };\n      \n      img.onerror = () => {\n        console.error('Error analyzing image');\n        resolve(true); // Assume blank on error\n      };\n      \n      img.src = imageData;\n    });\n  };\n  \n  // Function to capture image from video\n  const captureImage = useCallback(async () => {\n    if (!videoRef.current) {\n      console.warn('Video element not available');\n      return false;\n    }\n    \n    if (!isCameraReady) {\n      console.warn('Camera not ready yet');\n      return false;\n    }\n    \n    if (videoRef.current.videoWidth <= 0 || videoRef.current.videoHeight <= 0) {\n      console.warn('Video dimensions not available yet');\n      return false;\n    }\n    \n    console.log('Capturing image from video', {\n      videoWidth: videoRef.current.videoWidth,\n      videoHeight: videoRef.current.videoHeight,\n      readyState: videoRef.current.readyState\n    });\n    \n    try {\n      // Force a draw to make sure there's a frame to capture\n      if (videoRef.current.readyState < 2) {\n        console.warn('Video not fully loaded, waiting...');\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n      \n      // Ensure canvas dimensions match video\n      canvasRef.current.width = videoRef.current.videoWidth || 640;\n      canvasRef.current.height = videoRef.current.videoHeight || 480;\n      \n      // Draw the current video frame to canvas\n      const ctx = canvasRef.current.getContext('2d');\n      ctx.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n      \n      // Convert to data URL with higher quality\n      const imageDataUrl = canvasRef.current.toDataURL('image/jpeg', 0.95);\n      \n      console.log('Raw image captured, data URL length:', imageDataUrl.length);\n      \n      // Check if the image is blank\n      const isBlank = await isImageBlank(imageDataUrl);\n      \n      if (isBlank) {\n        console.warn('Captured image appears to be blank');\n        return false;\n      }\n      \n      console.log('Valid image captured successfully, data URL length:', imageDataUrl.length);\n      \n      // Store the image and notify parent component\n      setStoredImage(imageDataUrl);\n      setHasValidImage(true);\n      onImageCapture(imageDataUrl);\n      \n      // Process the image based on the current mode\n      if (captureMode === 'face') {\n        await processFaceRecognition(imageDataUrl);\n      } else if (captureMode === 'medical') {\n        await processMedicalImageAnalysis(imageDataUrl);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Error capturing image:', error);\n      return false;\n    }\n  }, [onImageCapture, isCameraReady, captureMode]);\n  \n  // Function to process face recognition\n  const processFaceRecognition = async (imageData) => {\n    try {\n      setFaceRecognitionLoading(true);\n      setFaceRecognitionResult(null);\n      \n      console.log('Sending image for face recognition...');\n      const response = await axios.post('http://localhost:8080/api/recognize-face', {\n        image: imageData\n      });\n      \n      console.log('Face recognition result:', response.data);\n      setFaceRecognitionResult(response.data);\n      \n      // Switch to medical image mode after face recognition is done\n      setCaptureMode('medical');\n      \n    } catch (error) {\n      console.error('Error in face recognition:', error);\n      setFaceRecognitionResult({\n        success: false,\n        error: error.response?.data?.error || 'Error processing face recognition'\n      });\n    } finally {\n      setFaceRecognitionLoading(false);\n    }\n  };\n  \n  // Function to process medical image analysis\n  const processMedicalImageAnalysis = async (imageData) => {\n    try {\n      setImageAnalysisLoading(true);\n      setImageAnalysisResult(null);\n      \n      console.log('Sending image for medical analysis...');\n      const response = await axios.post('http://localhost:8080/api/analyze-image', {\n        image: imageData\n      });\n      \n      console.log('Medical image analysis result:', response.data);\n      setImageAnalysisResult(response.data);\n      \n    } catch (error) {\n      console.error('Error in medical image analysis:', error);\n      setImageAnalysisResult({\n        success: false,\n        error: error.response?.data?.error || 'Error processing image analysis'\n      });\n    } finally {\n      setImageAnalysisLoading(false);\n    }\n  };\n  \n  // Manual capture button handler with status updates\n  const handleManualCapture = async () => {\n    if (isCameraReady) {\n      console.log('Manual capture triggered');\n      setCameraStatus(`Capturing ${captureMode === 'face' ? 'face' : 'medical'} image...`);\n      \n      const success = await captureImage();\n      \n      if (success) {\n        setCameraStatus(`${captureMode === 'face' ? 'Face' : 'Medical'} image captured successfully!`);\n      } else {\n        setCameraStatus('Failed to capture image. Try again.');\n      }\n      \n      // Reset status after a delay\n      setTimeout(() => {\n        setCameraStatus(isCameraReady ? 'Camera active' : 'Initializing camera...');\n      }, 2000);\n    }\n  };\n  \n  // Function to retry capture if needed\n  const handleRetryCapture = async () => {\n    setHasValidImage(false);\n    await handleManualCapture();\n  };\n  \n  // Reset capture mode when starting a new stream\n  useEffect(() => {\n    if (isActive) {\n      setCaptureMode('face');\n      setFaceRecognitionResult(null);\n      setImageAnalysisResult(null);\n    }\n  }, [isActive]);\n  \n  // When stream ends, ensure the parent has the latest image\n  useEffect(() => {\n    if (!isActive && storedImage) {\n      console.log('Stream ended, ensuring parent has the latest captured image');\n      onImageCapture(storedImage);\n    }\n  }, [isActive, storedImage, onImageCapture]);\n  \n  // Handle camera setup and teardown\n  useEffect(() => {\n    if (isActive && !cameraError) {\n      console.log('Starting camera');\n      setCameraStatus('Initializing camera...');\n      \n      // Reset hasValidImage but keep any stored image\n      if (!storedImage) {\n        setHasValidImage(false);\n      }\n      \n      // Only initialize the camera if it's not already ready\n      if (!isCameraReady || !streamRef.current) {\n        // Start camera with specific constraints for better quality\n        navigator.mediaDevices.getUserMedia({ \n          video: { \n            width: { ideal: 1280 },\n            height: { ideal: 720 },\n            facingMode: 'user'\n          } \n        })\n          .then(stream => {\n            console.log('Camera access granted');\n            streamRef.current = stream;\n            \n            if (videoRef.current) {\n              // Set srcObject to the stream\n              videoRef.current.srcObject = stream;\n              \n              // Listen for loadedmetadata event\n              videoRef.current.onloadedmetadata = () => {\n                console.log('Video metadata loaded');\n                \n                // Play the video\n                videoRef.current.play()\n                  .then(() => {\n                    console.log('Video playback started');\n                    setCameraStatus(`Camera active - Click \"Capture ${captureMode === 'face' ? 'Face' : 'Medical Image'}\" button when ready`);\n                    \n                    // Wait a moment to ensure video is actually rendering frames\n                    setTimeout(() => {\n                      setIsCameraReady(true);\n                    }, 1000);\n                  })\n                  .catch(error => {\n                    console.error('Error starting video playback:', error);\n                    setCameraError(true);\n                    setCameraStatus('Camera error: ' + error.message);\n                  });\n              };\n              \n              // Listen for errors\n              videoRef.current.onerror = (error) => {\n                console.error('Video element error:', error);\n                setCameraError(true);\n                setCameraStatus('Video error: ' + (error.message || 'Unknown error'));\n              };\n            }\n          })\n          .catch(error => {\n            console.error('Error accessing camera:', error);\n            setCameraError(true);\n            setCameraStatus('Camera access error: ' + error.message);\n          });\n      } else {\n        // Camera is already initialized, just update the status\n        setCameraStatus(`Camera active - Click \"Capture ${captureMode === 'face' ? 'Face' : 'Medical Image'}\" button when ready`);\n      }\n    } else if (!isActive) {\n      // Stop camera when stream ends\n      if (streamRef.current) {\n        console.log('Stopping camera');\n        setCameraStatus('Stopping camera...');\n        \n        // Stop all tracks\n        streamRef.current.getTracks().forEach(track => {\n          track.stop();\n          console.log(`Track ${track.kind} stopped`);\n        });\n        streamRef.current = null;\n        setIsCameraReady(false);\n        setCameraStatus('Camera stopped');\n      }\n    }\n    \n    return () => {\n      // Only stop the camera in the cleanup function if isActive is false\n      // This prevents stopping the camera when the component re-renders\n      if (!isActive && streamRef.current) {\n        console.log('Cleanup: stopping camera tracks');\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [isActive, cameraError, storedImage, captureMode]); // Added captureMode to dependencies\n  \n  // Render face recognition result\n  const renderFaceRecognition = () => {\n    if (faceRecognitionLoading) {\n      return <div className=\"analysis-loading\">Identifying person...</div>;\n    }\n    \n    if (faceRecognitionResult && faceRecognitionResult.success) {\n      return (\n        <div className=\"face-recognition-result\">\n          <h4>Person Identified:</h4>\n          <div className=\"person-info\">\n            <div className=\"person-id\">ID: {faceRecognitionResult.person_id}</div>\n            <div className=\"person-name\">{faceRecognitionResult.person_name}</div>\n            <div className=\"person-profession\">{faceRecognitionResult.person_profession}</div>\n            <div className=\"confidence\">Confidence: {faceRecognitionResult.confidence}%</div>\n            {faceRecognitionResult.reference_comparison && faceRecognitionResult.reference_image_url && (\n              <div className=\"reference-image-container\">\n                <p>Matched with reference image:</p>\n                <img \n                  src={`http://localhost:8080${faceRecognitionResult.reference_image_url}`} \n                  alt={`Reference for ${faceRecognitionResult.person_name}`} \n                  className=\"reference-image\"\n                />\n              </div>\n            )}\n            {faceRecognitionResult.is_fallback && (\n              <div className=\"fallback-notice\">\n                Note: Using simulated recognition (API issue)\n              </div>\n            )}\n          </div>\n        </div>\n      );\n    }\n    \n    if (faceRecognitionResult && !faceRecognitionResult.success) {\n      return (\n        <div className=\"face-recognition-error\">\n          <p>Error identifying person: {faceRecognitionResult.error}</p>\n        </div>\n      );\n    }\n    \n    return null;\n  };\n  \n  // Render medical image analysis result\n  const renderImageAnalysis = () => {\n    if (imageAnalysisLoading) {\n      return <div className=\"analysis-loading\">Analyzing image...</div>;\n    }\n    \n    if (imageAnalysisResult && imageAnalysisResult.success) {\n      return (\n        <div className=\"image-analysis-result\">\n          <h4>Image Analysis:</h4>\n          <div className=\"analysis-text\">{imageAnalysisResult.analysis}</div>\n          {imageAnalysisResult.is_fallback && (\n            <div className=\"fallback-notice\">\n              Note: Using simulated analysis (API issue)\n            </div>\n          )}\n        </div>\n      );\n    }\n    \n    if (imageAnalysisResult && !imageAnalysisResult.success) {\n      return (\n        <div className=\"image-analysis-error\">\n          <p>Error analyzing image: {imageAnalysisResult.error}</p>\n        </div>\n      );\n    }\n    \n    return null;\n  };\n  \n  return (\n    <div className=\"video-capture-container\">\n      <div className=\"video-capture\">\n        <video \n          ref={videoRef} \n          className={isActive ? 'active' : 'inactive'} \n          muted\n          playsInline\n          autoPlay\n        />\n        \n        {isActive && (\n          <div className=\"camera-controls\">\n            <div className=\"status-indicator\">\n              {cameraStatus}\n              {hasValidImage && <span className=\"checkmark\">âœ“</span>}\n            </div>\n            \n            <div className=\"buttons\">\n              <button \n                className=\"capture-button\"\n                onClick={handleManualCapture}\n                disabled={!isCameraReady}\n                title={`Take a ${captureMode === 'face' ? 'face' : 'medical'} image`}\n              >\n                ðŸ“· Capture {captureMode === 'face' ? 'Face' : 'Medical Image'}\n              </button>\n              \n              {hasValidImage && (\n                <button \n                  className=\"retry-button\"\n                  onClick={handleRetryCapture}\n                  disabled={!isCameraReady}\n                  title={`Capture a new ${captureMode === 'face' ? 'face' : 'medical'} image`}\n                >\n                  ðŸ”„ Retry\n                </button>\n              )}\n            </div>\n          </div>\n        )}\n        \n        {!isActive && hasValidImage && (\n          <div className=\"image-saved-indicator\">\n            <p>Image saved and will be sent with your audio</p>\n          </div>\n        )}\n        \n        {!isActive && !hasValidImage && (\n          <div className=\"camera-inactive\">\n            <p>No image captured. Start stream to use camera.</p>\n          </div>\n        )}\n        \n        {cameraError && (\n          <div className=\"camera-error\">\n            <p>{cameraStatus || 'Camera access error. Please check your permissions.'}</p>\n          </div>\n        )}\n      </div>\n      \n      <div className=\"image-analysis-container\">\n        {renderFaceRecognition()}\n        {renderImageAnalysis()}\n      </div>\n    </div>\n  );\n};\n\nexport default VideoCapture; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
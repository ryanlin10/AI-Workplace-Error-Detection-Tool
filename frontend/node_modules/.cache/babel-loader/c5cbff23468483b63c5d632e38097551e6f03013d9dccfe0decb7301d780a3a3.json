{"ast":null,"code":"var _jsxFileName = \"/Users/suleimanmahmood/Documents/software engineering stuff/BuildX2/frontend/src/components/VideoCapture.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport './VideoCapture.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoCapture = ({\n  isActive,\n  onImageCapture\n}) => {\n  _s();\n  const videoRef = useRef(null);\n  const streamRef = useRef(null);\n  const canvasRef = useRef(document.createElement('canvas'));\n  const [isCameraReady, setIsCameraReady] = useState(false);\n  const [cameraError, setCameraError] = useState(false);\n  const [hasValidImage, setHasValidImage] = useState(false);\n\n  // Function to check if an image is blank/black\n  const isImageBlank = imageData => {\n    // Create a temporary canvas to analyze the image\n    const tempCanvas = document.createElement('canvas');\n    const tempCtx = tempCanvas.getContext('2d');\n    const img = new Image();\n\n    // Set up a promise to handle the async image loading\n    return new Promise(resolve => {\n      img.onload = () => {\n        tempCanvas.width = img.width;\n        tempCanvas.height = img.height;\n        tempCtx.drawImage(img, 0, 0);\n\n        // Get image data and check if it's mostly black\n        const data = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;\n        let nonBlackPixels = 0;\n        const totalPixels = data.length / 4;\n\n        // Sample pixels to check for non-black content\n        for (let i = 0; i < data.length; i += 16) {\n          const r = data[i];\n          const g = data[i + 1];\n          const b = data[i + 2];\n\n          // If pixel is not black (allowing some noise)\n          if (r > 10 || g > 10 || b > 10) {\n            nonBlackPixels++;\n          }\n        }\n\n        // If less than 5% of sampled pixels are non-black, consider it blank\n        const isBlank = nonBlackPixels / (totalPixels / 4) < 0.05;\n        console.log(`Image analysis: ${nonBlackPixels} non-black pixels out of ${totalPixels / 4} sampled. Blank: ${isBlank}`);\n        resolve(isBlank);\n      };\n      img.onerror = () => {\n        console.error('Error analyzing image');\n        resolve(true); // Assume blank on error\n      };\n      img.src = imageData;\n    });\n  };\n\n  // Function to capture image from video\n  const captureImage = useCallback(async () => {\n    if (!videoRef.current || !isCameraReady) {\n      console.warn('Video element not ready for capture');\n      return false;\n    }\n    if (videoRef.current.videoWidth <= 0 || videoRef.current.videoHeight <= 0) {\n      console.warn('Video dimensions not available yet');\n      return false;\n    }\n    console.log('Capturing image from video', {\n      videoWidth: videoRef.current.videoWidth,\n      videoHeight: videoRef.current.videoHeight,\n      readyState: videoRef.current.readyState\n    });\n    try {\n      // Ensure canvas dimensions match video\n      canvasRef.current.width = videoRef.current.videoWidth;\n      canvasRef.current.height = videoRef.current.videoHeight;\n\n      // Draw the current video frame to canvas\n      const ctx = canvasRef.current.getContext('2d');\n      ctx.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n\n      // Convert to data URL\n      const imageDataUrl = canvasRef.current.toDataURL('image/jpeg', 0.9);\n\n      // Check if the image is blank\n      const isBlank = await isImageBlank(imageDataUrl);\n      if (isBlank) {\n        console.warn('Captured image appears to be blank');\n        return false;\n      }\n      console.log('Image captured successfully, data URL length:', imageDataUrl.length);\n      onImageCapture(imageDataUrl);\n      setHasValidImage(true);\n      return true;\n    } catch (error) {\n      console.error('Error capturing image:', error);\n      return false;\n    }\n  }, [onImageCapture, isCameraReady]);\n\n  // Periodic image capture during recording\n  useEffect(() => {\n    let captureInterval;\n    if (isActive && isCameraReady) {\n      // Wait a bit longer before first capture to ensure video is rendering\n      const initialCaptureDelay = 3000;\n      console.log(`Scheduling initial capture in ${initialCaptureDelay}ms`);\n      const initialCaptureTimeout = setTimeout(async () => {\n        const success = await captureImage();\n        if (!success) {\n          console.log('Initial capture failed, trying again in 2 seconds');\n          setTimeout(captureImage, 2000);\n        }\n      }, initialCaptureDelay);\n\n      // Set up interval to capture image every 5 seconds during recording\n      captureInterval = setInterval(async () => {\n        if (!hasValidImage) {\n          console.log('Attempting periodic capture');\n          await captureImage();\n        }\n      }, 5000);\n      return () => {\n        clearTimeout(initialCaptureTimeout);\n        if (captureInterval) {\n          clearInterval(captureInterval);\n        }\n      };\n    }\n    return () => {\n      if (captureInterval) {\n        clearInterval(captureInterval);\n      }\n    };\n  }, [isActive, isCameraReady, captureImage, hasValidImage]);\n\n  // Handle camera setup and teardown\n  useEffect(() => {\n    if (isActive && !isCameraReady && !cameraError) {\n      console.log('Starting camera');\n      setHasValidImage(false);\n\n      // Start camera with specific constraints for better quality\n      navigator.mediaDevices.getUserMedia({\n        video: {\n          width: {\n            ideal: 1280\n          },\n          height: {\n            ideal: 720\n          },\n          facingMode: 'user'\n        }\n      }).then(stream => {\n        console.log('Camera access granted');\n        streamRef.current = stream;\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream;\n          videoRef.current.onloadedmetadata = () => {\n            console.log('Video metadata loaded');\n            videoRef.current.play().then(() => {\n              console.log('Video playback started');\n              // Wait a moment to ensure video is actually rendering frames\n              setTimeout(() => {\n                setIsCameraReady(true);\n              }, 1000);\n            }).catch(error => {\n              console.error('Error starting video playback:', error);\n              setCameraError(true);\n            });\n          };\n        }\n      }).catch(error => {\n        console.error('Error accessing camera:', error);\n        setCameraError(true);\n      });\n    } else if (!isActive) {\n      // Stop camera and capture final image if we were active\n      if (streamRef.current && isCameraReady) {\n        console.log('Stopping camera and capturing final image');\n\n        // Try to capture one last image before stopping\n        const captureFinalImage = async () => {\n          // Try up to 3 times to get a non-blank image\n          for (let i = 0; i < 3; i++) {\n            console.log(`Final capture attempt ${i + 1}/3`);\n            const success = await captureImage();\n            if (success) {\n              console.log('Final capture successful');\n              break;\n            }\n            // Short delay between attempts\n            if (i < 2) {\n              await new Promise(resolve => setTimeout(resolve, 500));\n            }\n          }\n\n          // Stop all tracks\n          streamRef.current.getTracks().forEach(track => {\n            track.stop();\n            console.log(`Track ${track.kind} stopped`);\n          });\n          streamRef.current = null;\n          setIsCameraReady(false);\n        };\n        captureFinalImage();\n      }\n    }\n    return () => {\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [isActive, isCameraReady, captureImage, cameraError]);\n\n  // Manual capture button handler\n  const handleManualCapture = async () => {\n    if (isCameraReady) {\n      console.log('Manual capture triggered');\n      await captureImage();\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"video-capture\",\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      className: isActive ? 'active' : 'inactive',\n      muted: true,\n      playsInline: true,\n      autoPlay: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 239,\n      columnNumber: 7\n    }, this), isActive && isCameraReady && /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"capture-button\",\n      onClick: handleManualCapture,\n      title: \"Take a snapshot\",\n      children: \"\\uD83D\\uDCF7\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 248,\n      columnNumber: 9\n    }, this), hasValidImage && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"capture-indicator\",\n      children: \"\\u2713\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 258,\n      columnNumber: 9\n    }, this), !isActive && !isCameraReady && !cameraError && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"camera-inactive\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Click \\\"Start Stream\\\" to activate camera\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 263,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 262,\n      columnNumber: 9\n    }, this), cameraError && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"camera-error\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Camera access error. Please check your permissions.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 269,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 268,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 238,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoCapture, \"jJo5YjlcICZ6bZY0wFVEmTvEyI0=\");\n_c = VideoCapture;\nexport default VideoCapture;\nvar _c;\n$RefreshReg$(_c, \"VideoCapture\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","jsxDEV","_jsxDEV","VideoCapture","isActive","onImageCapture","_s","videoRef","streamRef","canvasRef","document","createElement","isCameraReady","setIsCameraReady","cameraError","setCameraError","hasValidImage","setHasValidImage","isImageBlank","imageData","tempCanvas","tempCtx","getContext","img","Image","Promise","resolve","onload","width","height","drawImage","data","getImageData","nonBlackPixels","totalPixels","length","i","r","g","b","isBlank","console","log","onerror","error","src","captureImage","current","warn","videoWidth","videoHeight","readyState","ctx","imageDataUrl","toDataURL","captureInterval","initialCaptureDelay","initialCaptureTimeout","setTimeout","success","setInterval","clearTimeout","clearInterval","navigator","mediaDevices","getUserMedia","video","ideal","facingMode","then","stream","srcObject","onloadedmetadata","play","catch","captureFinalImage","getTracks","forEach","track","stop","kind","handleManualCapture","className","children","ref","muted","playsInline","autoPlay","fileName","_jsxFileName","lineNumber","columnNumber","onClick","title","_c","$RefreshReg$"],"sources":["/Users/suleimanmahmood/Documents/software engineering stuff/BuildX2/frontend/src/components/VideoCapture.js"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\nimport './VideoCapture.css';\n\nconst VideoCapture = ({ isActive, onImageCapture }) => {\n  const videoRef = useRef(null);\n  const streamRef = useRef(null);\n  const canvasRef = useRef(document.createElement('canvas'));\n  const [isCameraReady, setIsCameraReady] = useState(false);\n  const [cameraError, setCameraError] = useState(false);\n  const [hasValidImage, setHasValidImage] = useState(false);\n  \n  // Function to check if an image is blank/black\n  const isImageBlank = (imageData) => {\n    // Create a temporary canvas to analyze the image\n    const tempCanvas = document.createElement('canvas');\n    const tempCtx = tempCanvas.getContext('2d');\n    const img = new Image();\n    \n    // Set up a promise to handle the async image loading\n    return new Promise((resolve) => {\n      img.onload = () => {\n        tempCanvas.width = img.width;\n        tempCanvas.height = img.height;\n        tempCtx.drawImage(img, 0, 0);\n        \n        // Get image data and check if it's mostly black\n        const data = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;\n        let nonBlackPixels = 0;\n        const totalPixels = data.length / 4;\n        \n        // Sample pixels to check for non-black content\n        for (let i = 0; i < data.length; i += 16) {\n          const r = data[i];\n          const g = data[i + 1];\n          const b = data[i + 2];\n          \n          // If pixel is not black (allowing some noise)\n          if (r > 10 || g > 10 || b > 10) {\n            nonBlackPixels++;\n          }\n        }\n        \n        // If less than 5% of sampled pixels are non-black, consider it blank\n        const isBlank = (nonBlackPixels / (totalPixels / 4)) < 0.05;\n        console.log(`Image analysis: ${nonBlackPixels} non-black pixels out of ${totalPixels / 4} sampled. Blank: ${isBlank}`);\n        resolve(isBlank);\n      };\n      \n      img.onerror = () => {\n        console.error('Error analyzing image');\n        resolve(true); // Assume blank on error\n      };\n      \n      img.src = imageData;\n    });\n  };\n  \n  // Function to capture image from video\n  const captureImage = useCallback(async () => {\n    if (!videoRef.current || !isCameraReady) {\n      console.warn('Video element not ready for capture');\n      return false;\n    }\n    \n    if (videoRef.current.videoWidth <= 0 || videoRef.current.videoHeight <= 0) {\n      console.warn('Video dimensions not available yet');\n      return false;\n    }\n    \n    console.log('Capturing image from video', {\n      videoWidth: videoRef.current.videoWidth,\n      videoHeight: videoRef.current.videoHeight,\n      readyState: videoRef.current.readyState\n    });\n    \n    try {\n      // Ensure canvas dimensions match video\n      canvasRef.current.width = videoRef.current.videoWidth;\n      canvasRef.current.height = videoRef.current.videoHeight;\n      \n      // Draw the current video frame to canvas\n      const ctx = canvasRef.current.getContext('2d');\n      ctx.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n      \n      // Convert to data URL\n      const imageDataUrl = canvasRef.current.toDataURL('image/jpeg', 0.9);\n      \n      // Check if the image is blank\n      const isBlank = await isImageBlank(imageDataUrl);\n      \n      if (isBlank) {\n        console.warn('Captured image appears to be blank');\n        return false;\n      }\n      \n      console.log('Image captured successfully, data URL length:', imageDataUrl.length);\n      onImageCapture(imageDataUrl);\n      setHasValidImage(true);\n      return true;\n    } catch (error) {\n      console.error('Error capturing image:', error);\n      return false;\n    }\n  }, [onImageCapture, isCameraReady]);\n  \n  // Periodic image capture during recording\n  useEffect(() => {\n    let captureInterval;\n    \n    if (isActive && isCameraReady) {\n      // Wait a bit longer before first capture to ensure video is rendering\n      const initialCaptureDelay = 3000;\n      console.log(`Scheduling initial capture in ${initialCaptureDelay}ms`);\n      \n      const initialCaptureTimeout = setTimeout(async () => {\n        const success = await captureImage();\n        if (!success) {\n          console.log('Initial capture failed, trying again in 2 seconds');\n          setTimeout(captureImage, 2000);\n        }\n      }, initialCaptureDelay);\n      \n      // Set up interval to capture image every 5 seconds during recording\n      captureInterval = setInterval(async () => {\n        if (!hasValidImage) {\n          console.log('Attempting periodic capture');\n          await captureImage();\n        }\n      }, 5000);\n      \n      return () => {\n        clearTimeout(initialCaptureTimeout);\n        if (captureInterval) {\n          clearInterval(captureInterval);\n        }\n      };\n    }\n    \n    return () => {\n      if (captureInterval) {\n        clearInterval(captureInterval);\n      }\n    };\n  }, [isActive, isCameraReady, captureImage, hasValidImage]);\n  \n  // Handle camera setup and teardown\n  useEffect(() => {\n    if (isActive && !isCameraReady && !cameraError) {\n      console.log('Starting camera');\n      setHasValidImage(false);\n      \n      // Start camera with specific constraints for better quality\n      navigator.mediaDevices.getUserMedia({ \n        video: { \n          width: { ideal: 1280 },\n          height: { ideal: 720 },\n          facingMode: 'user'\n        } \n      })\n        .then(stream => {\n          console.log('Camera access granted');\n          streamRef.current = stream;\n          \n          if (videoRef.current) {\n            videoRef.current.srcObject = stream;\n            videoRef.current.onloadedmetadata = () => {\n              console.log('Video metadata loaded');\n              \n              videoRef.current.play()\n                .then(() => {\n                  console.log('Video playback started');\n                  // Wait a moment to ensure video is actually rendering frames\n                  setTimeout(() => {\n                    setIsCameraReady(true);\n                  }, 1000);\n                })\n                .catch(error => {\n                  console.error('Error starting video playback:', error);\n                  setCameraError(true);\n                });\n            };\n          }\n        })\n        .catch(error => {\n          console.error('Error accessing camera:', error);\n          setCameraError(true);\n        });\n    } else if (!isActive) {\n      // Stop camera and capture final image if we were active\n      if (streamRef.current && isCameraReady) {\n        console.log('Stopping camera and capturing final image');\n        \n        // Try to capture one last image before stopping\n        const captureFinalImage = async () => {\n          // Try up to 3 times to get a non-blank image\n          for (let i = 0; i < 3; i++) {\n            console.log(`Final capture attempt ${i + 1}/3`);\n            const success = await captureImage();\n            if (success) {\n              console.log('Final capture successful');\n              break;\n            }\n            // Short delay between attempts\n            if (i < 2) {\n              await new Promise(resolve => setTimeout(resolve, 500));\n            }\n          }\n          \n          // Stop all tracks\n          streamRef.current.getTracks().forEach(track => {\n            track.stop();\n            console.log(`Track ${track.kind} stopped`);\n          });\n          streamRef.current = null;\n          setIsCameraReady(false);\n        };\n        \n        captureFinalImage();\n      }\n    }\n    \n    return () => {\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [isActive, isCameraReady, captureImage, cameraError]);\n  \n  // Manual capture button handler\n  const handleManualCapture = async () => {\n    if (isCameraReady) {\n      console.log('Manual capture triggered');\n      await captureImage();\n    }\n  };\n  \n  return (\n    <div className=\"video-capture\">\n      <video \n        ref={videoRef} \n        className={isActive ? 'active' : 'inactive'} \n        muted\n        playsInline\n        autoPlay\n      />\n      \n      {isActive && isCameraReady && (\n        <button \n          className=\"capture-button\" \n          onClick={handleManualCapture}\n          title=\"Take a snapshot\"\n        >\n          ðŸ“·\n        </button>\n      )}\n      \n      {hasValidImage && (\n        <div className=\"capture-indicator\">âœ“</div>\n      )}\n      \n      {!isActive && !isCameraReady && !cameraError && (\n        <div className=\"camera-inactive\">\n          <p>Click \"Start Stream\" to activate camera</p>\n        </div>\n      )}\n      \n      {cameraError && (\n        <div className=\"camera-error\">\n          <p>Camera access error. Please check your permissions.</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default VideoCapture; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
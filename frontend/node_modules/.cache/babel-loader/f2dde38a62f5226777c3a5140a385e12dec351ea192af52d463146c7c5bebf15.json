{"ast":null,"code":"var _jsxFileName = \"/Users/suleimanmahmood/Documents/software engineering stuff/BuildX2/frontend/src/components/VideoCapture.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState, useCallback } from 'react';\nimport './VideoCapture.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoCapture = ({\n  isActive,\n  onImageCapture\n}) => {\n  _s();\n  const videoRef = useRef(null);\n  const streamRef = useRef(null);\n  const canvasRef = useRef(document.createElement('canvas'));\n  const [isCameraReady, setIsCameraReady] = useState(false);\n  const [cameraError, setCameraError] = useState(false);\n  const [hasValidImage, setHasValidImage] = useState(false);\n  const [cameraStatus, setCameraStatus] = useState('Initializing camera...');\n  const [storedImage, setStoredImage] = useState(null);\n\n  // Function to check if an image is blank/black\n  const isImageBlank = imageData => {\n    // Create a temporary canvas to analyze the image\n    const tempCanvas = document.createElement('canvas');\n    const tempCtx = tempCanvas.getContext('2d');\n    const img = new Image();\n\n    // Set up a promise to handle the async image loading\n    return new Promise(resolve => {\n      img.onload = () => {\n        tempCanvas.width = img.width;\n        tempCanvas.height = img.height;\n        tempCtx.drawImage(img, 0, 0);\n\n        // Get image data and check if it's mostly black\n        const data = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;\n        let nonBlackPixels = 0;\n        const totalPixels = data.length / 4;\n\n        // Sample pixels to check for non-black content\n        for (let i = 0; i < data.length; i += 16) {\n          const r = data[i];\n          const g = data[i + 1];\n          const b = data[i + 2];\n\n          // If pixel is not black (allowing some noise)\n          if (r > 10 || g > 10 || b > 10) {\n            nonBlackPixels++;\n          }\n        }\n\n        // If less than 5% of sampled pixels are non-black, consider it blank\n        const isBlank = nonBlackPixels / (totalPixels / 4) < 0.05;\n        console.log(`Image analysis: ${nonBlackPixels} non-black pixels out of ${totalPixels / 4} sampled. Blank: ${isBlank}`);\n        resolve(isBlank);\n      };\n      img.onerror = () => {\n        console.error('Error analyzing image');\n        resolve(true); // Assume blank on error\n      };\n      img.src = imageData;\n    });\n  };\n\n  // Function to capture image from video\n  const captureImage = useCallback(async () => {\n    if (!videoRef.current) {\n      console.warn('Video element not available');\n      return false;\n    }\n    if (!isCameraReady) {\n      console.warn('Camera not ready yet');\n      return false;\n    }\n    if (videoRef.current.videoWidth <= 0 || videoRef.current.videoHeight <= 0) {\n      console.warn('Video dimensions not available yet');\n      return false;\n    }\n    console.log('Capturing image from video', {\n      videoWidth: videoRef.current.videoWidth,\n      videoHeight: videoRef.current.videoHeight,\n      readyState: videoRef.current.readyState\n    });\n    try {\n      // Force a draw to make sure there's a frame to capture\n      if (videoRef.current.readyState < 2) {\n        console.warn('Video not fully loaded, waiting...');\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n\n      // Ensure canvas dimensions match video\n      canvasRef.current.width = videoRef.current.videoWidth || 640;\n      canvasRef.current.height = videoRef.current.videoHeight || 480;\n\n      // Draw the current video frame to canvas\n      const ctx = canvasRef.current.getContext('2d');\n      ctx.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n\n      // Convert to data URL with higher quality\n      const imageDataUrl = canvasRef.current.toDataURL('image/jpeg', 0.95);\n      console.log('Raw image captured, data URL length:', imageDataUrl.length);\n\n      // Check if the image is blank\n      const isBlank = await isImageBlank(imageDataUrl);\n      if (isBlank) {\n        console.warn('Captured image appears to be blank');\n        return false;\n      }\n      console.log('Valid image captured successfully, data URL length:', imageDataUrl.length);\n\n      // Store the image and notify parent component\n      setStoredImage(imageDataUrl);\n      setHasValidImage(true);\n      onImageCapture(imageDataUrl);\n      return true;\n    } catch (error) {\n      console.error('Error capturing image:', error);\n      return false;\n    }\n  }, [onImageCapture, isCameraReady]);\n\n  // Manual capture button handler with status updates\n  const handleManualCapture = async () => {\n    if (isCameraReady) {\n      console.log('Manual capture triggered');\n      setCameraStatus('Capturing image...');\n      const success = await captureImage();\n      if (success) {\n        setCameraStatus('Image captured successfully!');\n      } else {\n        setCameraStatus('Failed to capture image. Try again.');\n      }\n\n      // Reset status after a delay\n      setTimeout(() => {\n        setCameraStatus(isCameraReady ? 'Camera active' : 'Initializing camera...');\n      }, 2000);\n    }\n  };\n\n  // Function to retry capture if needed\n  const handleRetryCapture = async () => {\n    setHasValidImage(false);\n    await handleManualCapture();\n  };\n\n  // When stream ends, ensure the parent has the latest image\n  useEffect(() => {\n    if (!isActive && storedImage) {\n      console.log('Stream ended, ensuring parent has the latest captured image');\n      onImageCapture(storedImage);\n    }\n  }, [isActive, storedImage, onImageCapture]);\n\n  // Handle camera setup and teardown\n  useEffect(() => {\n    if (isActive && !cameraError) {\n      console.log('Starting camera');\n      setCameraStatus('Initializing camera...');\n\n      // Reset hasValidImage but keep any stored image\n      if (!storedImage) {\n        setHasValidImage(false);\n      }\n\n      // Only initialize the camera if it's not already ready\n      if (!isCameraReady || !streamRef.current) {\n        // Start camera with specific constraints for better quality\n        navigator.mediaDevices.getUserMedia({\n          video: {\n            width: {\n              ideal: 1280\n            },\n            height: {\n              ideal: 720\n            },\n            facingMode: 'user'\n          }\n        }).then(stream => {\n          console.log('Camera access granted');\n          streamRef.current = stream;\n          if (videoRef.current) {\n            // Set srcObject to the stream\n            videoRef.current.srcObject = stream;\n\n            // Listen for loadedmetadata event\n            videoRef.current.onloadedmetadata = () => {\n              console.log('Video metadata loaded');\n\n              // Play the video\n              videoRef.current.play().then(() => {\n                console.log('Video playback started');\n                setCameraStatus('Camera active - Click \"Capture Image\" button when ready');\n\n                // Wait a moment to ensure video is actually rendering frames\n                setTimeout(() => {\n                  setIsCameraReady(true);\n                }, 1000);\n              }).catch(error => {\n                console.error('Error starting video playback:', error);\n                setCameraError(true);\n                setCameraStatus('Camera error: ' + error.message);\n              });\n            };\n\n            // Listen for errors\n            videoRef.current.onerror = error => {\n              console.error('Video element error:', error);\n              setCameraError(true);\n              setCameraStatus('Video error: ' + (error.message || 'Unknown error'));\n            };\n          }\n        }).catch(error => {\n          console.error('Error accessing camera:', error);\n          setCameraError(true);\n          setCameraStatus('Camera access error: ' + error.message);\n        });\n      } else {\n        // Camera is already initialized, just update the status\n        setCameraStatus('Camera active - Click \"Capture Image\" button when ready');\n      }\n    } else if (!isActive) {\n      // Stop camera when stream ends\n      if (streamRef.current) {\n        console.log('Stopping camera');\n        setCameraStatus('Stopping camera...');\n\n        // Stop all tracks\n        streamRef.current.getTracks().forEach(track => {\n          track.stop();\n          console.log(`Track ${track.kind} stopped`);\n        });\n        streamRef.current = null;\n        setIsCameraReady(false);\n        setCameraStatus('Camera stopped');\n      }\n    }\n    return () => {\n      // Only stop the camera in the cleanup function if isActive is false\n      // This prevents stopping the camera when the component re-renders\n      if (!isActive && streamRef.current) {\n        console.log('Cleanup: stopping camera tracks');\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [isActive, cameraError, storedImage]); // Removed isCameraReady from dependencies\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"video-capture\",\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      ref: videoRef,\n      className: isActive ? 'active' : 'inactive',\n      muted: true,\n      playsInline: true,\n      autoPlay: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 257,\n      columnNumber: 7\n    }, this), isActive && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"camera-controls\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"status-indicator\",\n        children: [cameraStatus, hasValidImage && /*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"checkmark\",\n          children: \"\\u2713\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 269,\n          columnNumber: 31\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 267,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"buttons\",\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"capture-button\",\n          onClick: handleManualCapture,\n          disabled: !isCameraReady,\n          title: \"Take a snapshot\",\n          children: \"\\uD83D\\uDCF7 Capture Image\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 273,\n          columnNumber: 13\n        }, this), hasValidImage && /*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"retry-button\",\n          onClick: handleRetryCapture,\n          disabled: !isCameraReady,\n          title: \"Capture a new image\",\n          children: \"\\uD83D\\uDD04 Retry\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 283,\n          columnNumber: 15\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 272,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 266,\n      columnNumber: 9\n    }, this), !isActive && hasValidImage && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"image-saved-indicator\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Image saved and will be sent with your audio\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 298,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 297,\n      columnNumber: 9\n    }, this), !isActive && !hasValidImage && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"camera-inactive\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"No image captured. Start stream to use camera.\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 304,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 303,\n      columnNumber: 9\n    }, this), cameraError && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"camera-error\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        children: cameraStatus || 'Camera access error. Please check your permissions.'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 310,\n        columnNumber: 11\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 309,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 256,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoCapture, \"kPKl4NOK35HHsBkXAhs4ud3nG1M=\");\n_c = VideoCapture;\nexport default VideoCapture;\nvar _c;\n$RefreshReg$(_c, \"VideoCapture\");","map":{"version":3,"names":["React","useRef","useEffect","useState","useCallback","jsxDEV","_jsxDEV","VideoCapture","isActive","onImageCapture","_s","videoRef","streamRef","canvasRef","document","createElement","isCameraReady","setIsCameraReady","cameraError","setCameraError","hasValidImage","setHasValidImage","cameraStatus","setCameraStatus","storedImage","setStoredImage","isImageBlank","imageData","tempCanvas","tempCtx","getContext","img","Image","Promise","resolve","onload","width","height","drawImage","data","getImageData","nonBlackPixels","totalPixels","length","i","r","g","b","isBlank","console","log","onerror","error","src","captureImage","current","warn","videoWidth","videoHeight","readyState","setTimeout","ctx","imageDataUrl","toDataURL","handleManualCapture","success","handleRetryCapture","navigator","mediaDevices","getUserMedia","video","ideal","facingMode","then","stream","srcObject","onloadedmetadata","play","catch","message","getTracks","forEach","track","stop","kind","className","children","ref","muted","playsInline","autoPlay","fileName","_jsxFileName","lineNumber","columnNumber","onClick","disabled","title","_c","$RefreshReg$"],"sources":["/Users/suleimanmahmood/Documents/software engineering stuff/BuildX2/frontend/src/components/VideoCapture.js"],"sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from 'react';\nimport './VideoCapture.css';\n\nconst VideoCapture = ({ isActive, onImageCapture }) => {\n  const videoRef = useRef(null);\n  const streamRef = useRef(null);\n  const canvasRef = useRef(document.createElement('canvas'));\n  const [isCameraReady, setIsCameraReady] = useState(false);\n  const [cameraError, setCameraError] = useState(false);\n  const [hasValidImage, setHasValidImage] = useState(false);\n  const [cameraStatus, setCameraStatus] = useState('Initializing camera...');\n  const [storedImage, setStoredImage] = useState(null);\n  \n  // Function to check if an image is blank/black\n  const isImageBlank = (imageData) => {\n    // Create a temporary canvas to analyze the image\n    const tempCanvas = document.createElement('canvas');\n    const tempCtx = tempCanvas.getContext('2d');\n    const img = new Image();\n    \n    // Set up a promise to handle the async image loading\n    return new Promise((resolve) => {\n      img.onload = () => {\n        tempCanvas.width = img.width;\n        tempCanvas.height = img.height;\n        tempCtx.drawImage(img, 0, 0);\n        \n        // Get image data and check if it's mostly black\n        const data = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;\n        let nonBlackPixels = 0;\n        const totalPixels = data.length / 4;\n        \n        // Sample pixels to check for non-black content\n        for (let i = 0; i < data.length; i += 16) {\n          const r = data[i];\n          const g = data[i + 1];\n          const b = data[i + 2];\n          \n          // If pixel is not black (allowing some noise)\n          if (r > 10 || g > 10 || b > 10) {\n            nonBlackPixels++;\n          }\n        }\n        \n        // If less than 5% of sampled pixels are non-black, consider it blank\n        const isBlank = (nonBlackPixels / (totalPixels / 4)) < 0.05;\n        console.log(`Image analysis: ${nonBlackPixels} non-black pixels out of ${totalPixels / 4} sampled. Blank: ${isBlank}`);\n        resolve(isBlank);\n      };\n      \n      img.onerror = () => {\n        console.error('Error analyzing image');\n        resolve(true); // Assume blank on error\n      };\n      \n      img.src = imageData;\n    });\n  };\n  \n  // Function to capture image from video\n  const captureImage = useCallback(async () => {\n    if (!videoRef.current) {\n      console.warn('Video element not available');\n      return false;\n    }\n    \n    if (!isCameraReady) {\n      console.warn('Camera not ready yet');\n      return false;\n    }\n    \n    if (videoRef.current.videoWidth <= 0 || videoRef.current.videoHeight <= 0) {\n      console.warn('Video dimensions not available yet');\n      return false;\n    }\n    \n    console.log('Capturing image from video', {\n      videoWidth: videoRef.current.videoWidth,\n      videoHeight: videoRef.current.videoHeight,\n      readyState: videoRef.current.readyState\n    });\n    \n    try {\n      // Force a draw to make sure there's a frame to capture\n      if (videoRef.current.readyState < 2) {\n        console.warn('Video not fully loaded, waiting...');\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n      \n      // Ensure canvas dimensions match video\n      canvasRef.current.width = videoRef.current.videoWidth || 640;\n      canvasRef.current.height = videoRef.current.videoHeight || 480;\n      \n      // Draw the current video frame to canvas\n      const ctx = canvasRef.current.getContext('2d');\n      ctx.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);\n      \n      // Convert to data URL with higher quality\n      const imageDataUrl = canvasRef.current.toDataURL('image/jpeg', 0.95);\n      \n      console.log('Raw image captured, data URL length:', imageDataUrl.length);\n      \n      // Check if the image is blank\n      const isBlank = await isImageBlank(imageDataUrl);\n      \n      if (isBlank) {\n        console.warn('Captured image appears to be blank');\n        return false;\n      }\n      \n      console.log('Valid image captured successfully, data URL length:', imageDataUrl.length);\n      \n      // Store the image and notify parent component\n      setStoredImage(imageDataUrl);\n      setHasValidImage(true);\n      onImageCapture(imageDataUrl);\n      \n      return true;\n    } catch (error) {\n      console.error('Error capturing image:', error);\n      return false;\n    }\n  }, [onImageCapture, isCameraReady]);\n  \n  // Manual capture button handler with status updates\n  const handleManualCapture = async () => {\n    if (isCameraReady) {\n      console.log('Manual capture triggered');\n      setCameraStatus('Capturing image...');\n      \n      const success = await captureImage();\n      \n      if (success) {\n        setCameraStatus('Image captured successfully!');\n      } else {\n        setCameraStatus('Failed to capture image. Try again.');\n      }\n      \n      // Reset status after a delay\n      setTimeout(() => {\n        setCameraStatus(isCameraReady ? 'Camera active' : 'Initializing camera...');\n      }, 2000);\n    }\n  };\n  \n  // Function to retry capture if needed\n  const handleRetryCapture = async () => {\n    setHasValidImage(false);\n    await handleManualCapture();\n  };\n  \n  // When stream ends, ensure the parent has the latest image\n  useEffect(() => {\n    if (!isActive && storedImage) {\n      console.log('Stream ended, ensuring parent has the latest captured image');\n      onImageCapture(storedImage);\n    }\n  }, [isActive, storedImage, onImageCapture]);\n  \n  // Handle camera setup and teardown\n  useEffect(() => {\n    if (isActive && !cameraError) {\n      console.log('Starting camera');\n      setCameraStatus('Initializing camera...');\n      \n      // Reset hasValidImage but keep any stored image\n      if (!storedImage) {\n        setHasValidImage(false);\n      }\n      \n      // Only initialize the camera if it's not already ready\n      if (!isCameraReady || !streamRef.current) {\n        // Start camera with specific constraints for better quality\n        navigator.mediaDevices.getUserMedia({ \n          video: { \n            width: { ideal: 1280 },\n            height: { ideal: 720 },\n            facingMode: 'user'\n          } \n        })\n          .then(stream => {\n            console.log('Camera access granted');\n            streamRef.current = stream;\n            \n            if (videoRef.current) {\n              // Set srcObject to the stream\n              videoRef.current.srcObject = stream;\n              \n              // Listen for loadedmetadata event\n              videoRef.current.onloadedmetadata = () => {\n                console.log('Video metadata loaded');\n                \n                // Play the video\n                videoRef.current.play()\n                  .then(() => {\n                    console.log('Video playback started');\n                    setCameraStatus('Camera active - Click \"Capture Image\" button when ready');\n                    \n                    // Wait a moment to ensure video is actually rendering frames\n                    setTimeout(() => {\n                      setIsCameraReady(true);\n                    }, 1000);\n                  })\n                  .catch(error => {\n                    console.error('Error starting video playback:', error);\n                    setCameraError(true);\n                    setCameraStatus('Camera error: ' + error.message);\n                  });\n              };\n              \n              // Listen for errors\n              videoRef.current.onerror = (error) => {\n                console.error('Video element error:', error);\n                setCameraError(true);\n                setCameraStatus('Video error: ' + (error.message || 'Unknown error'));\n              };\n            }\n          })\n          .catch(error => {\n            console.error('Error accessing camera:', error);\n            setCameraError(true);\n            setCameraStatus('Camera access error: ' + error.message);\n          });\n      } else {\n        // Camera is already initialized, just update the status\n        setCameraStatus('Camera active - Click \"Capture Image\" button when ready');\n      }\n    } else if (!isActive) {\n      // Stop camera when stream ends\n      if (streamRef.current) {\n        console.log('Stopping camera');\n        setCameraStatus('Stopping camera...');\n        \n        // Stop all tracks\n        streamRef.current.getTracks().forEach(track => {\n          track.stop();\n          console.log(`Track ${track.kind} stopped`);\n        });\n        streamRef.current = null;\n        setIsCameraReady(false);\n        setCameraStatus('Camera stopped');\n      }\n    }\n    \n    return () => {\n      // Only stop the camera in the cleanup function if isActive is false\n      // This prevents stopping the camera when the component re-renders\n      if (!isActive && streamRef.current) {\n        console.log('Cleanup: stopping camera tracks');\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n    };\n  }, [isActive, cameraError, storedImage]); // Removed isCameraReady from dependencies\n  \n  return (\n    <div className=\"video-capture\">\n      <video \n        ref={videoRef} \n        className={isActive ? 'active' : 'inactive'} \n        muted\n        playsInline\n        autoPlay\n      />\n      \n      {isActive && (\n        <div className=\"camera-controls\">\n          <div className=\"status-indicator\">\n            {cameraStatus}\n            {hasValidImage && <span className=\"checkmark\">âœ“</span>}\n          </div>\n          \n          <div className=\"buttons\">\n            <button \n              className=\"capture-button\"\n              onClick={handleManualCapture}\n              disabled={!isCameraReady}\n              title=\"Take a snapshot\"\n            >\n              ðŸ“· Capture Image\n            </button>\n            \n            {hasValidImage && (\n              <button \n                className=\"retry-button\"\n                onClick={handleRetryCapture}\n                disabled={!isCameraReady}\n                title=\"Capture a new image\"\n              >\n                ðŸ”„ Retry\n              </button>\n            )}\n          </div>\n        </div>\n      )}\n      \n      {!isActive && hasValidImage && (\n        <div className=\"image-saved-indicator\">\n          <p>Image saved and will be sent with your audio</p>\n        </div>\n      )}\n      \n      {!isActive && !hasValidImage && (\n        <div className=\"camera-inactive\">\n          <p>No image captured. Start stream to use camera.</p>\n        </div>\n      )}\n      \n      {cameraError && (\n        <div className=\"camera-error\">\n          <p>{cameraStatus || 'Camera access error. Please check your permissions.'}</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default VideoCapture; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}